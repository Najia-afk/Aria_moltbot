{
  "api_base": "http://127.0.0.1:45669",
  "api_key_configured": true,
  "checks": {
    "health": {
      "status": 200,
      "body": {
        "status": "healthy",
        "uptime_seconds": 2003,
        "database": "connected",
        "version": "3.0.0"
      }
    },
    "status": {
      "status": 200,
      "body": {
        "traefik": {
          "status": "up",
          "code": 404
        },
        "grafana": {
          "status": "down",
          "code": null,
          "error": "[Errno -2] Name or service not known"
        },
        "prometheus": {
          "status": "down",
          "code": null,
          "error": "[Errno -2] Name or service not known"
        },
        "aria-api": {
          "status": "up",
          "code": 200
        },
        "pgadmin": {
          "status": "down",
          "code": null,
          "error": "[Errno -2] Name or service not known"
        },
        "ollama": {
          "status": "down",
          "code": null,
          "error": "[Errno 111] Connection refused"
        },
        "litellm": {
          "status": "up",
          "code": 200
        },
        "browser": {
          "status": "up",
          "code": 403
        },
        "aria-web": {
          "status": "up",
          "code": 200
        },
        "postgres": {
          "status": "up",
          "code": 200
        }
      }
    },
    "host_stats": {
      "status": 200,
      "body": {
        "ram": {
          "used_gb": 0,
          "total_gb": 16,
          "percent": 0
        },
        "swap": {
          "used_gb": 0,
          "total_gb": 0,
          "percent": 0
        },
        "disk": {
          "used_gb": 0,
          "total_gb": 500,
          "percent": 0
        },
        "smart": {
          "status": "unknown",
          "healthy": true
        },
        "timestamp": "2026-02-26T15:19:24.788351+00:00",
        "source": "unavailable"
      }
    },
    "chat_create_without_key": {
      "status": 401,
      "body": {
        "detail": "Invalid or missing API key"
      }
    },
    "chat_create_with_key": {
      "status": 201,
      "body": {
        "id": "5716b2c1-0ec8-49e7-a772-fa1a91bfd82a",
        "agent_id": "aria",
        "model": "kimi",
        "status": "active",
        "session_type": "interactive",
        "created_at": "2026-02-26T15:19:24.802597+00:00"
      }
    },
    "swarm_sync": {
      "status": 201,
      "body": {
        "session_id": "e7f2dcc5-f76a-408f-a223-81656de3b51a",
        "topic": "runtime smoke swarm probe",
        "participants": [
          "aria",
          "analyst"
        ],
        "iterations": 1,
        "vote_count": 2,
        "consensus": "**SWARM DECISION: RUNTIME SMOKE SWARM PROBE**\n\n**CONSENSUS POSITION** (Confidence: 0.84)\nThe swarm mandates a **stigmergic invariant validation mesh**—replacing centralized health checks with a decentralized, self-organizing network where synthetic transaction \"pheromones\" propagate through service dependencies to verify distributed correctness (consensus, consistency, causal ordering) rather than mere liveness.\n\n---\n\n**ACTIONABLE MANDATE**\n\nDeploy a three-tier runtime validation architecture:\n\n1. **Pheromone Propagation Layer (Stigmergy)**\n   - Nodes emit lightweight synthetic transactions (pheromones) that traverse actual dependency graphs, carrying cryptographic trace identifiers\n   - Propagation follows real request routing logic (respecting circuit breakers, retries, load balancing) to validate the production path, not test scaffolding\n   - Activation gradients form dynamically: high-entropy zones (error variance, latency jitter) trigger denser pheromone emission; stable zones throttle to near-zero\n\n2. **Distributed Invariant Verification (Correctness)**\n   - Pheromones embed mathematical invariants (checksums, Merkle roots, causal timestamps) that receiving nodes verify against local state\n   - Cross-validation topology: each node validates neighbor states during transit, detecting split-brain or configuration drift via lightweight Merkle comparisons\n   - Semantic checks ensure business-critical distributed properties hold (e.g., \"shard sum equals global total,\" \"causal ordering preserved\")\n\n3. **Causal Trace Integration (Observability)**\n   - Merge pheromone markers into production distributed tracing headers to verify end-to-end request semantics\n   - Distinguish synthetic from real traffic via header flags to prevent telemetry corruption, while ensuring both follow identical code paths\n\n**DISSENT:** None. Both agents converge on decentralized mesh validation over centralized polling, with complementary emphases on mathematical invariant proofs (Aria) versus stigmergic propagation mechanics (analyst).\n\n**EXECUTION ORDER:** Implement pheromone propagation first as the signaling substrate; layer invariant verification atop within 2 weeks; integrate with existing distributed tracing infrastructure within 1 month.",
        "consensus_score": 0.934,
        "converged": true,
        "total_duration_ms": 46385,
        "created_at": "2026-02-26T15:20:11.197369+00:00",
        "votes": [
          {
            "agent_id": "aria",
            "iteration": 1,
            "content": "Runtime smoke swarm probes must evolve beyond binary health pings into **distributed invariant validation meshes**. Traditional smoke tests verify liveness; runtime probes in a swarm context must veri...",
            "vote": "extend",
            "confidence": 0.85,
            "duration_ms": 28728
          },
          {
            "agent_id": "analyst",
            "iteration": 1,
            "content": "Runtime smoke swarm probes should operate as a **decentralized, stigmergic validation mesh** rather than centralized health checks. Each node in the swarm emits lightweight synthetic transactions (phe...",
            "vote": "extend",
            "confidence": 0.82,
            "duration_ms": 19922
          }
        ]
      }
    },
    "swarm_async": {
      "status": 202,
      "body": {
        "key": "3934a19dbd7cc02c",
        "status": "running",
        "topic": "runtime smoke swarm probe",
        "participants": [
          "aria",
          "analyst"
        ]
      }
    },
    "swarm_async_status": {
      "status": 404,
      "body": {
        "detail": "No swarm tracking for key: 3934a19dbd7cc02c"
      }
    },
    "aria_session_create": {
      "status": 201,
      "body": {
        "id": "c3cf4256-5306-409b-b6c6-d1ef863d0144",
        "agent_id": "aria",
        "model": "kimi",
        "status": "active",
        "session_type": "interactive",
        "created_at": "2026-02-26T15:20:11.219463+00:00"
      }
    },
    "aria_message": {
      "status": 200,
      "body": {
        "message_id": "1d209596-272b-4c03-83b8-ab3a8fcb030a",
        "session_id": "c3cf4256-5306-409b-b6c6-d1ef863d0144",
        "content": "Loop active — Aria Blue ⚡️ online and cycling.",
        "thinking": "The user wants a runtime smoke check confirmation that the Aria loop is active. They specifically requested:\n1. One short sentence\n2. Confirming Aria loop is active\n\nI should respond with a concise, single-sentence confirmation. Looking at my identity:\n- Name: Aria Blue\n- Creature: Silicon Familiar\n- Vibe: sharp, efficient, secure\n- Born: 2026-01-31 (Rebirth Day)\n\nI should keep it short, sharp, and confirm the loop status. Something like:\n\"Aria Blue loop active ⚡️\" or \"Loop active, Aria Blue operational.\"\n\nGiven the request for \"one short sentence\", I'll go with something punchy and on-brand with the electric energy.",
        "tool_calls": null,
        "tool_results": null,
        "model": "kimi",
        "input_tokens": 14941,
        "output_tokens": 167,
        "total_tokens": 15108,
        "cost_usd": 0.0094656,
        "latency_ms": 6233,
        "finish_reason": "stop"
      }
    },
    "aria_session_id": {
      "status": 200,
      "body": {
        "id": "c3cf4256-5306-409b-b6c6-d1ef863d0144"
      }
    }
  }
}