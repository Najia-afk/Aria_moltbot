"""
Tool Registry — Translates aria_skills into LiteLLM tool definitions.

Bridges the gap between:
- aria_skills with their skill.json manifests and Python methods
- LiteLLM's OpenAI-compatible function calling format

Handles:
- Auto-discovery from skill.json manifests
- Function signature → JSON Schema conversion
- Direct Python execution (no subprocess)
- Result formatting for LLM consumption
- Timeout enforcement and error handling
"""
import asyncio
import inspect
import json
import logging
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Callable

from aria_engine.exceptions import ToolError

logger = logging.getLogger("aria.engine.tools")


@dataclass
class ToolDefinition:
    """A tool that can be called by the LLM."""
    name: str
    description: str
    parameters: dict[str, Any]
    skill_name: str
    function_name: str
    _handler: Callable | None = field(default=None, repr=False)


@dataclass
class ToolResult:
    """Result of a tool execution."""
    tool_call_id: str
    name: str
    content: str
    success: bool = True
    duration_ms: int = 0


class ToolRegistry:
    """
    Discovers and manages tools from aria_skills.

    Usage:
        registry = ToolRegistry()
        registry.discover_from_skills(skill_registry)

        # Get tool definitions for LLM:
        tools = registry.get_tools_for_llm()

        # Execute a tool call:
        result = await registry.execute(tool_call_id, function_name, arguments)
    """

    def __init__(self, timeout_seconds: int = 300):
        self._tools: dict[str, ToolDefinition] = {}
        self._skill_instances: dict[str, Any] = {}
        self._initialized_skills: set[str] = set()
        self._timeout = timeout_seconds

    def discover_from_skills(self, skill_registry) -> int:
        """
        Auto-discover tools from the skill registry.

        Reads skill.json manifests and public methods to build tool definitions.
        Returns count of registered tools.
        """
        count = 0
        skills_dir = Path(__file__).parent.parent / "aria_skills"

        for skill_dir in skills_dir.iterdir():
            if not skill_dir.is_dir() or skill_dir.name.startswith("_"):
                continue

            manifest_path = skill_dir / "skill.json"
            if not manifest_path.exists():
                continue

            try:
                manifest = json.loads(manifest_path.read_text())
                skill_name = manifest.get("name", skill_dir.name)

                # Get the skill instance from registry
                skill = skill_registry.get(skill_dir.name)
                if not skill:
                    continue

                self._skill_instances[skill_dir.name] = skill

                # Register each tool from manifest
                tools = manifest.get("tools", [])
                for tool_def in tools:
                    tool_name = f"{skill_dir.name}__{tool_def['name']}"
                    self._tools[tool_name] = ToolDefinition(
                        name=tool_name,
                        description=tool_def.get("description", ""),
                        parameters=tool_def.get("parameters", {"type": "object", "properties": {}}),
                        skill_name=skill_dir.name,
                        function_name=tool_def["name"],
                        _handler=getattr(skill, tool_def["name"], None),
                    )
                    count += 1

            except Exception as e:
                logger.warning("Failed to discover tools from %s: %s", skill_dir.name, e)

        logger.info("Discovered %d tools from %d skills", count, len(self._skill_instances))
        return count

    def discover_from_manifests(self, skills_base: str | Path | None = None) -> int:
        """
        Auto-discover tools from skill.json manifests only (no live instances needed).

        Reads each aria_skills/*/skill.json to register tool definitions for
        LLM function calling. Handlers are bound lazily on first execution via
        _lazy_import_handler().

        After registration, validates each handler is importable and removes
        orphan tools (manifest exists but no Python handler).

        Args:
            skills_base: Optional path to aria_skills directory. Defaults to
                ``/aria_skills`` (Docker mount) or sibling ``aria_skills/``.

        Returns:
            Number of verified tools registered.
        """
        if skills_base:
            skills_dir = Path(skills_base)
        else:
            # Try Docker mount path first, then relative to this file
            docker_path = Path("/aria_skills")
            local_path = Path(__file__).parent.parent / "aria_skills"
            skills_dir = docker_path if docker_path.is_dir() else local_path

        if not skills_dir.is_dir():
            logger.warning("Skills directory not found: %s", skills_dir)
            return 0

        count = 0
        skill_stats: dict[str, dict] = {}
        for skill_dir in sorted(skills_dir.iterdir()):
            if not skill_dir.is_dir() or skill_dir.name.startswith("_"):
                continue

            manifest_path = skill_dir / "skill.json"
            if not manifest_path.exists():
                continue

            try:
                manifest = json.loads(manifest_path.read_text(encoding="utf-8"))
                tools = manifest.get("tools", [])
                registered = 0
                for tool_def in tools:
                    tool_name = f"{skill_dir.name}__{tool_def['name']}"
                    if tool_name in self._tools:
                        continue  # Already registered by discover_from_skills

                    self._tools[tool_name] = ToolDefinition(
                        name=tool_name,
                        description=tool_def.get("description", ""),
                        parameters=tool_def.get("parameters", {
                            "type": "object", "properties": {},
                        }),
                        skill_name=skill_dir.name,
                        function_name=tool_def["name"],
                        _handler=None,  # Lazy — bound on first call
                    )
                    registered += 1
                    count += 1

                skill_stats[skill_dir.name] = {"manifest_tools": len(tools), "registered": registered}

            except Exception as e:
                logger.warning("Failed to read manifest from %s: %s", skill_dir.name, e)

        logger.info("Discovered %d tool definitions from %d skill manifests", count, len(skill_stats))

        # ── Handler Validation ────────────────────────────────────────────
        # Try to import each skill and bind handlers eagerly.
        # Skills that fail to import stay registered with lazy handlers.
        # Only truly un-importable skills (no __init__.py) are removed.
        verified = 0
        lazy = 0
        removed = 0
        verified_skills: list[str] = []
        removed_skills: list[str] = []

        for skill_name, stats in skill_stats.items():
            try:
                import importlib
                mod = importlib.import_module(f"aria_skills.{skill_name}")

                # Find the primary skill class (inherits BaseSkill or has execute methods)
                skill_cls = None
                for attr_name in dir(mod):
                    cls = getattr(mod, attr_name)
                    if not isinstance(cls, type) or cls.__module__ != mod.__name__:
                        continue
                    # Prefer classes that inherit BaseSkill
                    if any(base.__name__ == "BaseSkill" for base in cls.__mro__):
                        skill_cls = cls
                        break
                    # Fallback: any class defined in this module
                    if skill_cls is None:
                        skill_cls = cls

                if skill_cls is None:
                    # Namespace package or empty module — no usable class, remove tools
                    skill_tools = [name for name, t in self._tools.items() if t.skill_name == skill_name]
                    for tool_name in skill_tools:
                        del self._tools[tool_name]
                    removed += len(skill_tools)
                    removed_skills.append(f"{skill_name}({len(skill_tools)})")
                    continue

                # Try instantiation with SkillConfig (most skills need it)
                instance = None
                try:
                    from aria_skills.base import SkillConfig
                    instance = skill_cls(SkillConfig(name=skill_name))
                except TypeError:
                    try:
                        instance = skill_cls()
                    except Exception:
                        pass

                if instance is None:
                    # Can't instantiate — keep tools as lazy (will try again at call time)
                    lazy += stats["registered"]
                    continue

                self._skill_instances[skill_name] = instance

                # Bind handlers for all tools from this skill
                skill_tools = [t for t in self._tools.values() if t.skill_name == skill_name]
                bound = 0
                for tool in skill_tools:
                    handler = getattr(instance, tool.function_name, None)
                    if handler is not None:
                        tool._handler = handler
                        bound += 1
                    else:
                        lazy += 1  # Method name mismatch — stays lazy

                if bound > 0:
                    verified += bound
                    verified_skills.append(f"{skill_name}({bound})")

            except ImportError:
                # No __init__.py — genuine orphan, remove tools
                skill_tools = [name for name, t in self._tools.items() if t.skill_name == skill_name]
                for tool_name in skill_tools:
                    del self._tools[tool_name]
                removed += len(skill_tools)
                removed_skills.append(f"{skill_name}({len(skill_tools)})")
            except Exception as e:
                # Other error (syntax, dependency) — keep as lazy
                lazy += stats["registered"]
                logger.debug("Skill %s init failed (kept lazy): %s", skill_name, e)

        logger.info(
            "Tool validation: %d verified, %d lazy, %d removed. "
            "Verified: [%s]. Removed: [%s]",
            verified, lazy, removed,
            ", ".join(verified_skills[:15]),
            ", ".join(removed_skills) if removed_skills else "none",
        )
        return len(self._tools)

    def _lazy_import_handler(self, tool: ToolDefinition) -> Callable | None:
        """Attempt to import and bind a skill handler on first call."""
        if tool.skill_name in self._skill_instances:
            handler = getattr(self._skill_instances[tool.skill_name], tool.function_name, None)
            tool._handler = handler
            return handler

        # Try dynamic import: aria_skills.<skill>
        try:
            import importlib
            mod = importlib.import_module(f"aria_skills.{tool.skill_name}")

            # Find the primary skill class
            skill_cls = None
            for attr_name in dir(mod):
                cls = getattr(mod, attr_name)
                if not isinstance(cls, type) or cls.__module__ != mod.__name__:
                    continue
                if any(base.__name__ == "BaseSkill" for base in cls.__mro__):
                    skill_cls = cls
                    break
                if skill_cls is None:
                    skill_cls = cls

            if skill_cls is None:
                return None

            # Try instantiation with SkillConfig, then without
            instance = None
            try:
                from aria_skills.base import SkillConfig
                instance = skill_cls(SkillConfig(name=tool.skill_name))
            except (TypeError, ImportError):
                try:
                    instance = skill_cls()
                except Exception:
                    pass

            if instance is None:
                return None

            self._skill_instances[tool.skill_name] = instance
            handler = getattr(instance, tool.function_name, None)
            tool._handler = handler
            return handler
        except Exception as e:
            logger.debug("Lazy import failed for %s: %s", tool.skill_name, e)

        return None

    def register_tool(
        self,
        name: str,
        description: str,
        parameters: dict[str, Any],
        handler: Callable,
        skill_name: str = "custom",
    ):
        """Manually register a tool."""
        self._tools[name] = ToolDefinition(
            name=name,
            description=description,
            parameters=parameters,
            skill_name=skill_name,
            function_name=name,
            _handler=handler,
        )

    def get_tools_for_llm(self, filter_skills: list[str] | None = None) -> list[dict[str, Any]]:
        """
        Get tool definitions in OpenAI function calling format.

        Returns list of tool dicts compatible with litellm's tools parameter.
        """
        tools = []
        for name, tool in self._tools.items():
            if filter_skills and tool.skill_name not in filter_skills:
                continue

            tools.append({
                "type": "function",
                "function": {
                    "name": name,
                    "description": tool.description,
                    "parameters": tool.parameters,
                },
            })

        return tools

    async def execute(
        self,
        tool_call_id: str,
        function_name: str,
        arguments: str | dict[str, Any],
    ) -> ToolResult:
        """
        Execute a tool call from the LLM.

        Args:
            tool_call_id: ID from the LLM's tool call
            function_name: Function name (format: skill__method)
            arguments: JSON string or dict of arguments

        Returns:
            ToolResult with stringified content
        """
        start = time.monotonic()

        tool = self._tools.get(function_name)
        if not tool:
            return ToolResult(
                tool_call_id=tool_call_id,
                name=function_name,
                content=json.dumps({"error": f"Unknown tool: {function_name}"}),
                success=False,
            )

        if not tool._handler:
            # Try lazy import before giving up
            tool._handler = self._lazy_import_handler(tool)
            if not tool._handler:
                return ToolResult(
                    tool_call_id=tool_call_id,
                    name=function_name,
                    content=json.dumps({"error": f"No handler for tool: {function_name}"}),
                    success=False,
                )

        # Lazy-initialize skill instance on first use
        skill_name = tool.skill_name
        if skill_name not in self._initialized_skills:
            instance = self._skill_instances.get(skill_name)
            if instance is not None and hasattr(instance, "initialize"):
                try:
                    ok = await instance.initialize()
                    if ok:
                        logger.info("Lazy-initialized skill: %s", skill_name)
                    else:
                        logger.warning("Skill %s initialize() returned False", skill_name)
                except Exception as init_err:
                    logger.warning("Skill %s initialize() failed: %s", skill_name, init_err)
            self._initialized_skills.add(skill_name)

        # Parse arguments
        if isinstance(arguments, str):
            try:
                args = json.loads(arguments)
            except json.JSONDecodeError:
                args = {"input": arguments}
        else:
            args = arguments

        try:
            # Execute with timeout
            if asyncio.iscoroutinefunction(tool._handler):
                result = await asyncio.wait_for(
                    tool._handler(**args),
                    timeout=self._timeout,
                )
            else:
                loop = asyncio.get_event_loop()
                result = await asyncio.wait_for(
                    loop.run_in_executor(None, lambda: tool._handler(**args)),
                    timeout=self._timeout,
                )

            elapsed_ms = int((time.monotonic() - start) * 1000)

            # Format result
            if hasattr(result, "to_dict"):
                content = json.dumps(result.to_dict())
            elif hasattr(result, "data"):
                content = json.dumps({"success": getattr(result, "success", True), "data": result.data})
            elif isinstance(result, (dict, list)):
                content = json.dumps(result)
            else:
                content = str(result)

            return ToolResult(
                tool_call_id=tool_call_id,
                name=function_name,
                content=content,
                success=True,
                duration_ms=elapsed_ms,
            )

        except asyncio.TimeoutError:
            elapsed_ms = int((time.monotonic() - start) * 1000)
            return ToolResult(
                tool_call_id=tool_call_id,
                name=function_name,
                content=json.dumps({"error": f"Tool timed out after {self._timeout}s"}),
                success=False,
                duration_ms=elapsed_ms,
            )
        except Exception as e:
            elapsed_ms = int((time.monotonic() - start) * 1000)
            logger.error("Tool execution failed: %s — %s", function_name, e)
            return ToolResult(
                tool_call_id=tool_call_id,
                name=function_name,
                content=json.dumps({"error": str(e)}),
                success=False,
                duration_ms=elapsed_ms,
            )

    def list_tools(self) -> list[dict[str, str]]:
        """List all registered tools (for debugging)."""
        return [
            {
                "name": t.name,
                "skill": t.skill_name,
                "function": t.function_name,
                "description": t.description[:100],
            }
            for t in self._tools.values()
        ]
