{% extends "base.html" %}
{% block title %}Patterns{% endblock %}

{% block extra_css %}
<style>
    .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 15px; margin-bottom: 25px; }
    .stat-card { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 10px; padding: 18px; }
    .stat-card h4 { font-size: 11px; color: var(--text-muted); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.03em; }
    .stat-card .value { font-size: 22px; font-weight: 700; color: var(--text-primary); }
    .stat-card.blue .value { color: var(--accent-blue); }
    .stat-card.green .value { color: var(--success); }
    .stat-card.orange .value { color: #f59e0b; }
    .stat-card.purple .value { color: #a855f7; }
    .stat-card.red .value { color: #ef4444; }

    .charts-row { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px; }
    .chart-card { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; }
    .chart-card h4 { font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; }
    .chart-note { font-size: 11px; color: var(--text-muted); margin-bottom: 8px; }
    .chart-card canvas { max-height: 280px; }

    .pattern-list { display: grid; gap: 10px; }
    .pattern-card { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 10px; padding: 14px 16px; display: flex; gap: 14px; align-items: flex-start; }
    .pattern-type-indicator { width: 4px; border-radius: 4px; min-height: 40px; flex-shrink: 0; }
    .pattern-type-indicator.topic { background: #3b82f6; }
    .pattern-type-indicator.temporal { background: #a855f7; }
    .pattern-type-indicator.sentiment { background: #f59e0b; }
    .pattern-type-indicator.emergence { background: #22c55e; }
    .pattern-type-indicator.gap { background: #ef4444; }
    .pattern-body { flex: 1; min-width: 0; }
    .pattern-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
    .pattern-subject { font-weight: 600; font-size: 13px; color: var(--text-primary); }
    .pattern-time { font-size: 11px; color: var(--text-muted); }
    .pattern-content { font-size: 13px; color: var(--text-secondary); line-height: 1.5; }
    .pattern-meta { display: flex; gap: 10px; margin-top: 6px; font-size: 11px; color: var(--text-muted); }
    .pattern-badge { padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; }
    .pattern-badge.topic { background: rgba(59,130,246,0.15); color: #3b82f6; }
    .pattern-badge.temporal { background: rgba(168,85,247,0.15); color: #a855f7; }
    .pattern-badge.sentiment { background: rgba(245,158,11,0.15); color: #f59e0b; }
    .pattern-badge.emergence { background: rgba(34,197,94,0.15); color: #22c55e; }
    .pattern-badge.gap { background: rgba(239,68,68,0.15); color: #ef4444; }

    .confidence-bar { background: rgba(255,255,255,0.08); border-radius: 5px; height: 10px; width: 100px; display: inline-block; vertical-align: middle; overflow: hidden; }
    .confidence-fill { height: 100%; display: block; border-radius: 5px; transition: width 0.4s ease; background: linear-gradient(90deg, var(--conf-color-start, #ef4444), var(--conf-color-end, #22c55e)); }
    .confidence-fill.low { background: linear-gradient(90deg, #dc2626, #ef4444); box-shadow: 0 0 6px rgba(239,68,68,0.4); }
    .confidence-fill.med { background: linear-gradient(90deg, #d97706, #f59e0b); box-shadow: 0 0 6px rgba(245,158,11,0.4); }
    .confidence-fill.good { background: linear-gradient(90deg, #2563eb, #3b82f6); box-shadow: 0 0 6px rgba(59,130,246,0.35); }
    .confidence-fill.high { background: linear-gradient(90deg, #16a34a, #22c55e); box-shadow: 0 0 6px rgba(34,197,94,0.4); }
    .conf-score { font-weight: 700; font-size: 12px; }
    .conf-score.low { color: #ef4444; }
    .conf-score.med { color: #f59e0b; }
    .conf-score.good { color: #3b82f6; }
    .conf-score.high { color: #22c55e; }

    .page-controls { display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; }
    .page-controls select { padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); font-size: 13px; }
    .page-controls button { padding: 8px 16px; border: 1px solid var(--accent-blue); border-radius: 8px; background: var(--accent-blue); color: white; font-size: 13px; cursor: pointer; font-weight: 600; }
    .page-controls button:hover { opacity: 0.9; }
    .empty-state { text-align: center; padding: 50px 20px; color: var(--text-secondary); background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; }

    @media (max-width: 768px) { .charts-row { grid-template-columns: 1fr; } }
</style>
{% endblock %}

{% block content %}
<div class="page-header">
    <h1>üîç Pattern Recognition</h1>
    <p>Detect recurring themes, temporal behaviours, emerging interests, and knowledge gaps</p>
</div>

<div class="stats-grid">
    <div class="stat-card blue">
        <h4>Total Patterns</h4>
        <div class="value" id="stat-total">-</div>
    </div>
    <div class="stat-card blue">
        <h4>Topic Recurrence</h4>
        <div class="value" id="stat-topic">-</div>
    </div>
    <div class="stat-card purple">
        <h4>Temporal</h4>
        <div class="value" id="stat-temporal">-</div>
    </div>
    <div class="stat-card green">
        <h4>Emerging</h4>
        <div class="value" id="stat-emerging">-</div>
    </div>
    <div class="stat-card red">
        <h4>Knowledge Gaps</h4>
        <div class="value" id="stat-gap">-</div>
    </div>
</div>

<div class="charts-row">
    <div class="chart-card">
        <h4>Patterns by Type</h4>
        <canvas id="typeChart"></canvas>
    </div>
    <div class="chart-card">
        <h4>Confidence by Type (%)</h4>
        <div class="chart-note">Bars use the same pattern types as the pie chart</div>
        <canvas id="confidenceChart"></canvas>
    </div>
</div>

<div class="page-controls">
    <select id="typeFilter">
        <option value="">All Types</option>
        <option value="topic_recurrence">Topic Recurrence</option>
        <option value="temporal_pattern">Temporal Pattern</option>
        <option value="sentiment_drift">Sentiment Drift</option>
        <option value="interest_emergence">Interest Emergence</option>
        <option value="knowledge_gap">Knowledge Gap</option>
    </select>
    <button id="btnDetect" onclick="runDetection()">üîÑ Run Detection</button>
</div>

<div id="patternList" class="pattern-list">
    <div class="empty-state">Loading patterns...</div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
const API = window.ARIA_API_BASE_URL || '';
let allPatterns = [];
let allMemories = 0;  // total memories in the system
let typeChart, confidenceChart;

const TYPE_COLORS = {
    topic_recurrence: '#3b82f6',
    temporal_pattern: '#a855f7',
    sentiment_drift: '#f59e0b',
    interest_emergence: '#22c55e',
    knowledge_gap: '#ef4444',
    behavior_cycle: '#6366f1',
};

const TYPE_CLASS = {
    topic_recurrence: 'topic',
    temporal_pattern: 'temporal',
    sentiment_drift: 'sentiment',
    interest_emergence: 'emergence',
    knowledge_gap: 'gap',
};

function getConfidenceBand(confPct) {
    if (confPct >= 90) return 'high';
    if (confPct >= 70) return 'good';
    if (confPct >= 50) return 'med';
    return 'low';
}

function getRelativeConfidence(confPct, scale) {
    if (!scale || scale.range <= 0) return 1;
    const normalized = (confPct - scale.min) / scale.range;
    return Math.max(0, Math.min(1, normalized));
}

function getConfidenceColor(normalizedConfidence, lightness = 52) {
    const clamped = Math.max(0, Math.min(1, normalizedConfidence));
    const hue = Math.round(clamped * 120);
    const safeLightness = Math.max(35, Math.min(70, lightness));
    return `hsl(${hue}, 78%, ${safeLightness}%)`;
}

function getConfidenceGradient(normalizedConfidence) {
    return {
        start: getConfidenceColor(normalizedConfidence, 42),
        end: getConfidenceColor(normalizedConfidence, 56),
    };
}

function getConfidenceScale(patterns) {
    const values = patterns
        .map(p => {
            const m = p.metadata || {};
            return Math.round((m.confidence || p.importance || 0) * 100);
        })
        .filter(v => Number.isFinite(v));

    if (!values.length) return { min: 0, max: 100, range: 100 };
    const min = Math.min(...values);
    const max = Math.max(...values);
    return { min, max, range: Math.max(0, max - min) };
}

async function loadPatterns() {
    try {
        const resp = await fetch(`${API}/analysis/patterns/history?limit=100`);
        const data = await resp.json();
        allPatterns = data.items || [];

        // Also check how many memories are available for analysis
        try {
            const memResp = await fetch(`${API}/memories/semantic?limit=1`);
            const memData = await memResp.json();
            allMemories = memData.total || (memData.items || []).length || 0;
        } catch(e) { allMemories = 0; }

        updateStats();
        updateCharts();
        renderList();
    } catch(e) {
        document.getElementById('patternList').innerHTML =
            '<div class="empty-state">Failed to load patterns ‚Äî API may be offline</div>';
    }
}

function updateStats() {
    document.getElementById('stat-total').textContent = allPatterns.length || '0';
    const byType = {};
    allPatterns.forEach(p => {
        const t = (p.metadata || {}).pattern_type || 'unknown';
        byType[t] = (byType[t] || 0) + 1;
    });
    document.getElementById('stat-topic').textContent = byType.topic_recurrence || 0;
    document.getElementById('stat-temporal').textContent = byType.temporal_pattern || 0;
    document.getElementById('stat-emerging').textContent = (byType.interest_emergence || 0);
    document.getElementById('stat-gap').textContent = byType.knowledge_gap || 0;
}

function updateCharts() {
    const byType = {};
    const confidenceByType = {};
    const confidenceCounts = {};

    allPatterns.forEach(p => {
        const m = p.metadata || {};
        const t = m.pattern_type || 'unknown';
        byType[t] = (byType[t] || 0) + 1;
        const c = m.confidence || p.importance || 0;
        confidenceByType[t] = (confidenceByType[t] || 0) + c;
        confidenceCounts[t] = (confidenceCounts[t] || 0) + 1;
    });

    const typeLabels = Object.keys(byType);
    const typeData = Object.values(byType);
    const typeColors = typeLabels.map(t => TYPE_COLORS[t] || '#6b7280');

    if (typeChart) typeChart.destroy();
    if (typeLabels.length > 0) {
        typeChart = new Chart(document.getElementById('typeChart'), {
            type: 'doughnut',
            data: { labels: typeLabels.map(t => t.replace(/_/g, ' ')), datasets: [{ data: typeData, backgroundColor: typeColors, borderWidth: 0 }] },
            options: { responsive: true, plugins: { legend: { position: 'bottom', labels: { color: '#aaa', font: { size: 11 } } } } }
        });
    } else {
        // Empty doughnut placeholder
        typeChart = new Chart(document.getElementById('typeChart'), {
            type: 'doughnut',
            data: { labels: ['No data'], datasets: [{ data: [1], backgroundColor: ['#374151'], borderWidth: 0 }] },
            options: { responsive: true, plugins: { legend: { display: false } } }
        });
    }

    if (confidenceChart) confidenceChart.destroy();
    if (typeLabels.length > 0) {
        const avgConfByType = typeLabels.map(t => {
            const total = confidenceByType[t] || 0;
            const count = confidenceCounts[t] || 1;
            return Math.round((total / count) * 100);
        });

        confidenceChart = new Chart(document.getElementById('confidenceChart'), {
            type: 'bar',
            data: {
                labels: typeLabels.map(t => t.replace(/_/g, ' ')),
                datasets: [{ data: avgConfByType, backgroundColor: typeColors, borderRadius: 6 }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    x: { grid: { display: false }, ticks: { color: '#aaa' } },
                    y: {
                        min: 0,
                        max: 100,
                        grid: { color: 'rgba(255,255,255,0.05)' },
                        ticks: {
                            color: '#aaa',
                            stepSize: 20,
                            callback: (value) => `${value}%`
                        }
                    }
                }
            }
        });
    } else {
        confidenceChart = new Chart(document.getElementById('confidenceChart'), {
            type: 'bar',
            data: { labels: ['No data'], datasets: [{ data: [0], backgroundColor: ['#374151'], borderRadius: 6 }] },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    x: { grid: { display: false }, ticks: { color: '#aaa' } },
                    y: { min: 0, max: 100, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#aaa', stepSize: 20, callback: (value) => `${value}%` } }
                }
            }
        });
    }
}

function renderList() {
    const filter = document.getElementById('typeFilter').value;
    const filtered = filter
        ? allPatterns.filter(p => (p.metadata || {}).pattern_type === filter)
        : allPatterns;
    const confScale = getConfidenceScale(filtered);

    if (!filtered.length) {
        let html = '<div class="empty-state">';
        html += '<h3 style="margin-bottom:10px">üîç No patterns detected yet</h3>';
        if (allMemories > 0) {
            html += `<p style="margin-bottom:15px">${allMemories} memories available for analysis. Click <strong>Run Detection</strong> above to discover recurring themes, temporal patterns, and emerging interests.</p>`;
        } else {
            html += '<p style="margin-bottom:15px">Patterns will appear as Aria processes more conversations and the memory bridge cron job seeds data every 3 hours.</p>';
        }
        html += '<p style="font-size:12px;color:var(--text-muted)">Pattern types: topic recurrence, temporal, sentiment drift, interest emergence, knowledge gaps</p>';
        html += '</div>';
        document.getElementById('patternList').innerHTML = html;
        return;
    }

    document.getElementById('patternList').innerHTML = filtered.map(p => {
        const m = p.metadata || {};
        const pType = m.pattern_type || 'unknown';
        const cls = TYPE_CLASS[pType] || 'topic';
        const conf = (m.confidence || p.importance || 0);
        const confPct = Math.round(conf * 100);
        const confBand = getConfidenceBand(confPct);
        const confRelative = getRelativeConfidence(confPct, confScale);
        const confColor = getConfidenceColor(confRelative, 55);
        const confGradient = getConfidenceGradient(confRelative);
        const confWidthPct = Math.max(3, Math.min(100, confPct));
        const evidence = (m.evidence || []).join(', ') || '';
        const dt = p.created_at ? new Date(p.created_at).toLocaleString() : '';

        return `
        <div class="pattern-card">
            <div class="pattern-type-indicator ${cls}"></div>
            <div class="pattern-body">
                <div class="pattern-header">
                    <span class="pattern-subject">${m.subject || p.content}</span>
                    <span class="pattern-time">${dt}</span>
                </div>
                <div class="pattern-content">${p.content}</div>
                <div class="pattern-meta">
                    <span class="pattern-badge ${cls}">${pType.replace(/_/g, ' ')}</span>
                    <span>Confidence: <span class="confidence-bar"><span class="confidence-fill ${confBand}" style="width:${confWidthPct}%; --conf-color-start:${confGradient.start}; --conf-color-end:${confGradient.end}"></span></span> <span class="conf-score ${confBand}" style="color:${confColor}">${confPct}%</span></span>
                    ${evidence ? `<span>Evidence: ${evidence}</span>` : ''}
                </div>
            </div>
        </div>`;
    }).join('');
}

async function runDetection() {
    const btn = document.getElementById('btnDetect');
    btn.disabled = true;
    btn.textContent = '‚è≥ Running...';
    try {
        const resp = await fetch(`${API}/analysis/patterns/detect`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ min_confidence: 0.3, store: true })
        });
        const data = await resp.json();
        const found = data.patterns_found || 0;
        btn.textContent = `‚úÖ Found ${found} pattern${found !== 1 ? 's' : ''}`;
        setTimeout(() => { btn.textContent = 'üîÑ Run Detection'; btn.disabled = false; }, 3000);
        loadPatterns();
    } catch(e) {
        btn.textContent = '‚ùå Failed';
        setTimeout(() => { btn.textContent = 'üîÑ Run Detection'; btn.disabled = false; }, 3000);
    }
}

document.getElementById('typeFilter').addEventListener('change', renderList);
loadPatterns();
</script>
{% endblock %}
