{% extends "base.html" %}
{% block title %}Sentiment{% endblock %}

{% block extra_css %}
<style>
    .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 15px; margin-bottom: 25px; }
    .stat-card { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 10px; padding: 18px; }
    .stat-card h4 { font-size: 11px; color: var(--text-muted); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.03em; }
    .stat-card .value { font-size: 22px; font-weight: 700; color: var(--text-primary); }
    .stat-card.green .value { color: var(--success); }
    .stat-card.red .value { color: #ef4444; }
    .stat-card.yellow .value { color: #f59e0b; }
    .stat-card.blue .value { color: var(--accent-blue); }
    .stat-card.purple .value { color: #a855f7; }

    .charts-row { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px; }
    .chart-card { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; }
    .chart-card h4 { font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 12px; }
    .chart-card canvas { max-height: 260px; }

    .sentiment-list { display: grid; gap: 10px; }
    .sentiment-card { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 10px; padding: 14px 16px; display: flex; gap: 14px; align-items: flex-start; }
    .sentiment-indicator { width: 4px; border-radius: 4px; min-height: 40px; flex-shrink: 0; }
    .sentiment-indicator.positive { background: #22c55e; }
    .sentiment-indicator.negative { background: #ef4444; }
    .sentiment-indicator.uncertain { background: #f59e0b; }
    .sentiment-indicator.neutral { background: #6b7280; }
    .sentiment-body { flex: 1; min-width: 0; }
    .sentiment-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
    .sentiment-emotion { font-weight: 600; font-size: 13px; text-transform: capitalize; }
    .sentiment-emotion.positive { color: #22c55e; }
    .sentiment-emotion.negative { color: #ef4444; }
    .sentiment-emotion.uncertain { color: #f59e0b; }
    .sentiment-emotion.neutral { color: #6b7280; }
    .sentiment-time { font-size: 11px; color: var(--text-muted); }
    .sentiment-content { font-size: 13px; color: var(--text-secondary); line-height: 1.5; word-break: break-word; }
    .sentiment-meta { display: flex; gap: 10px; margin-top: 6px; font-size: 11px; color: var(--text-muted); flex-wrap: wrap; }
    .speaker-badge { display: inline-flex; align-items: center; gap: 3px; padding: 1px 7px; border-radius: 8px; font-size: 10px; font-weight: 600; }
    .speaker-badge.user { background: rgba(99,102,241,0.15); color: #818cf8; }
    .speaker-badge.assistant { background: rgba(14,165,233,0.15); color: #38bdf8; }
    .speaker-badge.system { background: rgba(107,114,128,0.2); color: #9ca3af; }
    .sentiment-badge { padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; }
    .sentiment-badge.positive { background: rgba(34,197,94,0.15); color: #22c55e; }
    .sentiment-badge.negative { background: rgba(239,68,68,0.15); color: #ef4444; }
    .sentiment-badge.uncertain { background: rgba(245,158,11,0.15); color: #f59e0b; }
    .sentiment-badge.neutral { background: rgba(107,114,128,0.2); color: #9ca3af; }

    .page-controls { display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; }
    .page-controls select, .page-controls input { padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); font-size: 13px; }
    .empty-state { text-align: center; padding: 50px 20px; color: var(--text-secondary); background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; }

    /* Score Gauge */
    .score-section { display: grid; grid-template-columns: 280px 1fr; gap: 20px; margin-bottom: 25px; }
    .score-gauge-card { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 24px; display: flex; flex-direction: column; align-items: center; justify-content: center; }
    .score-gauge { position: relative; width: 180px; height: 180px; }
    .score-gauge canvas { width: 180px; height: 180px; }
    .score-value { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
    .score-number { font-size: 42px; font-weight: 800; line-height: 1; }
    .score-label { font-size: 12px; color: var(--text-muted); margin-top: 4px; text-transform: uppercase; letter-spacing: 0.05em; }
    .score-trend { display: flex; align-items: center; gap: 6px; margin-top: 12px; font-size: 13px; font-weight: 600; }
    .score-trend.improving { color: #22c55e; }
    .score-trend.declining { color: #ef4444; }
    .score-trend.stable { color: #6b7280; }
    .score-details { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 14px; width: 100%; }
    .score-detail { text-align: center; }
    .score-detail-val { font-size: 16px; font-weight: 700; color: var(--text-primary); }
    .score-detail-lbl { font-size: 10px; color: var(--text-muted); text-transform: uppercase; }

    .score-timeline-card { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; }
    .score-timeline-card h4 { font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 12px; }
    .score-timeline-card canvas { max-height: 220px; }

    .emotion-chips { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 10px; }
    .emotion-chip { padding: 3px 10px; border-radius: 12px; font-size: 11px; font-weight: 600; background: var(--bg-tertiary, var(--bg-secondary)); border: 1px solid var(--border-color); }

    @media (max-width: 768px) { .charts-row { grid-template-columns: 1fr; } .score-section { grid-template-columns: 1fr; } }
</style>
{% endblock %}

{% block content %}
<div class="page-header">
    <h1>ğŸ’­ Sentiment Dashboard</h1>
    <p>Track Aria's overall sentiment â€” adapts tone, detects frustration, measures engagement</p>
</div>

<!-- Score Gauge + Timeline -->
<div class="score-section">
    <div class="score-gauge-card" id="score-gauge-card">
        <div class="score-gauge">
            <canvas id="gauge-canvas" width="180" height="180"></canvas>
            <div class="score-value">
                <div class="score-number" id="score-number">--</div>
                <div class="score-label">Sentiment</div>
            </div>
        </div>
        <div class="score-trend stable" id="score-trend">
            <span>â€”</span><span>Loadingâ€¦</span>
        </div>
        <div class="score-details">
            <div class="score-detail"><div class="score-detail-val" id="sd-valence">--</div><div class="score-detail-lbl">Valence</div></div>
            <div class="score-detail"><div class="score-detail-val" id="sd-arousal">--</div><div class="score-detail-lbl">Arousal</div></div>
            <div class="score-detail"><div class="score-detail-val" id="sd-dominance">--</div><div class="score-detail-lbl">Dominance</div></div>
            <div class="score-detail"><div class="score-detail-val" id="sd-confidence">--</div><div class="score-detail-lbl">Confidence</div></div>
        </div>
        <div class="emotion-chips" id="emotion-chips"></div>
    </div>
    <div class="score-timeline-card">
        <h4>ğŸ“ˆ Sentiment Score Timeline (24h)</h4>
        <canvas id="chart-score-timeline"></canvas>
    </div>
</div>

<div class="stats-grid">
    <div class="stat-card blue">
        <h4>Total Events</h4>
        <div class="value" id="stat-total">-</div>
    </div>
    <div class="stat-card green">
        <h4>Positive</h4>
        <div class="value" id="stat-positive">-</div>
    </div>
    <div class="stat-card red">
        <h4>Negative</h4>
        <div class="value" id="stat-negative">-</div>
    </div>
    <div class="stat-card yellow">
        <h4>Uncertain</h4>
        <div class="value" id="stat-uncertain">-</div>
    </div>
    <div class="stat-card purple">
        <h4>Avg Importance</h4>
        <div class="value" id="stat-importance">-</div>
    </div>
</div>

<div class="charts-row">
    <div class="chart-card">
        <h4>ğŸ“Š Sentiment Distribution</h4>
        <canvas id="chart-distribution"></canvas>
    </div>
    <div class="chart-card">
        <h4>ğŸ“ˆ Sentiment Timeline</h4>
        <canvas id="chart-timeline"></canvas>
    </div>
</div>

<div class="page-controls">
    <select id="filter-sentiment" onchange="renderFiltered()">
        <option value="">All Sentiments</option>
        <option value="positive">Positive</option>
        <option value="negative">Negative</option>
        <option value="uncertain">Uncertain</option>
        <option value="neutral">Neutral</option>
    </select>
    <select id="filter-speaker" onchange="renderFiltered()">
        <option value="">All Speakers</option>
    </select>
    <select id="filter-agent" onchange="renderFiltered()">
        <option value="">All Agents</option>
    </select>
    <label style="display:flex;align-items:center;gap:6px;font-size:13px;color:var(--text-secondary);cursor:pointer">
        <input type="checkbox" id="hide-neutral" checked onchange="renderFiltered()" style="accent-color:var(--accent-blue)">
        Hide neutral
    </label>
    <span style="font-size:13px;color:var(--text-muted)" id="result-count"></span>
</div>

<h3 style="font-size:15px;font-weight:600;margin-bottom:12px">ğŸ’¬ Recent Sentiment Events</h3>
<div class="sentiment-list" id="sentiment-list">
    <div class="empty-state">Loading sentiment data...</div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
const API = window.ARIA_API_BASE_URL || '';
const _charts = {};
let _allItems = [];
let _seedItems = [];  // all seeded memories for context

// â”€â”€ Score Gauge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawGauge(score) {
    const canvas = document.getElementById('gauge-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = 180, h = 180, cx = w/2, cy = h/2, r = 70, lw = 14;
    ctx.clearRect(0, 0, w, h);

    // Background arc
    ctx.beginPath();
    ctx.arc(cx, cy, r, Math.PI * 0.75, Math.PI * 2.25);
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = lw;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Score arc
    const pct = Math.max(0, Math.min(100, score)) / 100;
    const endAngle = Math.PI * 0.75 + pct * Math.PI * 1.5;
    const grad = ctx.createLinearGradient(0, h, w, 0);
    if (score >= 60) { grad.addColorStop(0, '#22c55e'); grad.addColorStop(1, '#4ade80'); }
    else if (score >= 40) { grad.addColorStop(0, '#f59e0b'); grad.addColorStop(1, '#fbbf24'); }
    else { grad.addColorStop(0, '#ef4444'); grad.addColorStop(1, '#f87171'); }

    ctx.beginPath();
    ctx.arc(cx, cy, r, Math.PI * 0.75, endAngle);
    ctx.strokeStyle = grad;
    ctx.lineWidth = lw;
    ctx.lineCap = 'round';
    ctx.stroke();
}

function getScoreColor(score) {
    if (score >= 60) return '#22c55e';
    if (score >= 40) return '#f59e0b';
    return '#ef4444';
}

async function loadScore() {
    try {
        const resp = await fetchWithRetry(`${API}/analysis/sentiment/score?hours=24`);
        const data = await resp.json();

        const score = data.score ?? 50;
        drawGauge(score);
        const numEl = document.getElementById('score-number');
        numEl.textContent = Math.round(score);
        numEl.style.color = getScoreColor(score);

        // Trend
        const trendEl = document.getElementById('score-trend');
        const arrows = { improving: 'â†‘ Improving', declining: 'â†“ Declining', stable: 'â†’ Stable' };
        trendEl.className = `score-trend ${data.trend || 'stable'}`;
        trendEl.innerHTML = `<span>${arrows[data.trend] || 'â†’ Stable'}</span><span style="font-weight:400;color:var(--text-muted)">${data.total_events} events</span>`;

        // Details
        document.getElementById('sd-valence').textContent = (data.avg_valence ?? 0).toFixed(2);
        document.getElementById('sd-arousal').textContent = (data.avg_arousal ?? 0).toFixed(2);
        document.getElementById('sd-dominance').textContent = (data.avg_dominance ?? 0).toFixed(2);
        document.getElementById('sd-confidence').textContent = ((data.avg_confidence ?? 0) * 100).toFixed(0) + '%';

        // Emotion chips
        const chips = document.getElementById('emotion-chips');
        const emotionIcons = {frustrated:'ğŸ˜¤',happy:'ğŸ˜„',neutral:'ğŸ˜¶',satisfied:'ğŸ˜Š',excited:'ğŸ‰',sad:'ğŸ˜¢',confused:'ğŸ¤”',assertive:'ğŸ’ª',angry:'ğŸ˜¡'};
        chips.innerHTML = (data.top_emotions || []).slice(0, 6).map(e =>
            `<span class="emotion-chip">${emotionIcons[e.emotion]||'ğŸ˜'} ${e.emotion} <b>${e.count}</b></span>`
        ).join('');

        // Score timeline chart
        renderScoreTimeline(data.timeline || []);
    } catch (err) {
        console.error('Failed to load score:', err);
        document.getElementById('score-number').textContent = '?';
    }
}

function renderScoreTimeline(timeline) {
    if (_charts['scoreLine']) _charts['scoreLine'].destroy();
    const ctx = document.getElementById('chart-score-timeline');
    if (!ctx || !timeline.length) return;

    const labels = timeline.map(t => {
        const d = new Date(t.hour);
        return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
    });
    const scores = timeline.map(t => t.score);
    const counts = timeline.map(t => t.count);

    _charts['scoreLine'] = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels,
            datasets: [
                {
                    label: 'Score',
                    data: scores,
                    borderColor: '#8b5cf6',
                    backgroundColor: 'rgba(139,92,246,0.1)',
                    fill: true,
                    tension: 0.4,
                    pointRadius: 3,
                    yAxisID: 'y',
                },
                {
                    label: 'Events',
                    data: counts,
                    borderColor: 'rgba(255,255,255,0.2)',
                    backgroundColor: 'rgba(255,255,255,0.05)',
                    fill: true,
                    type: 'bar',
                    yAxisID: 'y1',
                },
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            plugins: {
                legend: { position: 'bottom', labels: { color: '#94a3b8', font: { size: 11 } } },
                tooltip: {
                    callbacks: {
                        label: (ctx) => ctx.dataset.label === 'Score'
                            ? `Score: ${ctx.raw}/100`
                            : `${ctx.raw} events`
                    }
                }
            },
            scales: {
                x: { ticks: { color: '#94a3b8', maxRotation: 45, font: { size: 10 } }, grid: { display: false } },
                y: { min: 0, max: 100, ticks: { color: '#94a3b8', stepSize: 25 }, grid: { color: 'rgba(255,255,255,0.05)' }, title: { display: true, text: 'Score', color: '#94a3b8' } },
                y1: { position: 'right', beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { display: false }, title: { display: true, text: 'Events', color: '#94a3b8' } }
            }
        }
    });
}

// â”€â”€ Sentiment Data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function loadSentiment() {
    try {
        // 1. Fetch sentiment-specific memories
        const resp = await fetchWithRetry(`${API}/analysis/sentiment/history?limit=300`);
        const data = await resp.json();
        _allItems = sanitizeSentimentItems(data.items || []);

        // 2. If no sentiment data, also fetch all seeded memories as context
        if (_allItems.length === 0) {
            try {
                const seedResp = await fetchWithRetry(`${API}/memories/semantic?limit=100`);
                const seedData = await seedResp.json();
                _seedItems = seedData.items || [];
            } catch(e) { _seedItems = []; }
        }

        renderStats(_allItems);
        renderCharts(_allItems);
        renderList(_allItems);

        // Populate speaker filter dynamically from data
        const speakerIcons = {user:'ğŸ‘¤', assistant:'ğŸ¤–', system:'âš™ï¸'};
        const speakerLabels = {user:'User', assistant:'Aria', system:'System'};
        const speakers = [...new Set(_allItems.map(i => i.speaker || 'user'))].sort();
        const speakerSel = document.getElementById('filter-speaker');
        const curSpeaker = speakerSel.value;
        speakerSel.innerHTML = '<option value="">All Speakers</option>' +
            speakers.map(s => `<option value="${s}"${s === curSpeaker ? ' selected' : ''}>${speakerIcons[s]||'â“'} ${speakerLabels[s]||s}</option>`).join('');

        // Populate agent filter dynamically from data
        const agents = [...new Set(_allItems.map(i => i.agent_id).filter(Boolean))].sort();
        const agentSel = document.getElementById('filter-agent');
        const curAgent = agentSel.value;
        agentSel.innerHTML = '<option value="">All Agents</option>' +
            agents.map(a => `<option value="${escapeHtml(a)}"${a === curAgent ? ' selected' : ''}>${escapeHtml(a)}</option>`).join('');
    } catch (err) {
        document.getElementById('sentiment-list').innerHTML =
            `<div class="empty-state">Failed to load sentiment data: ${escapeHtml(err.message)}</div>`;
    }
}

function renderStats(items) {
    const positive = items.filter(i => getSentiment(i) === 'positive').length;
    const negative = items.filter(i => getSentiment(i) === 'negative').length;
    const uncertain = items.filter(i => getSentiment(i) === 'uncertain').length;
    const avgImp = items.length > 0
        ? (items.reduce((s, i) => s + (i.importance || 0), 0) / items.length).toFixed(2)
        : '-';

    document.getElementById('stat-total').textContent = items.length || (_seedItems.length ? `0 (${_seedItems.length} memories available)` : '0');
    document.getElementById('stat-positive').textContent = positive;
    document.getElementById('stat-negative').textContent = negative;
    document.getElementById('stat-uncertain').textContent = uncertain;
    document.getElementById('stat-importance').textContent = avgImp;
}

function inferSentimentFromValence(valence) {
    if (typeof valence !== 'number') return 'neutral';
    if (valence >= 0.25) return 'positive';
    if (valence <= -0.25) return 'negative';
    return 'neutral';
}

function normalizeSentimentLabel(raw) {
    const value = String(raw || '').toLowerCase().trim();
    if (value === 'positive' || value === 'negative' || value === 'uncertain' || value === 'neutral') return value;
    if (value === 'mixed' || value === 'unknown' || value === 'confused') return 'uncertain';
    if (value === 'frustration' || value === 'angry' || value === 'sad') return 'negative';
    if (value === 'happy' || value === 'satisfaction' || value === 'satisfied' || value === 'excited') return 'positive';
    return '';
}

function getSentData(item) {
    const meta = item.metadata || {};
    const nested = (meta.sentiment && typeof meta.sentiment === 'object') ? meta.sentiment : null;

    const valence = typeof meta.valence === 'number' ? meta.valence : (nested && typeof nested.valence === 'number' ? nested.valence : null);
    const primaryEmotion = (nested && nested.dominant_emotion) || meta.primary_emotion || 'neutral';
    const inferredFromValence = inferSentimentFromValence(valence);
    const sentiment = normalizeSentimentLabel(
        (nested && nested.sentiment)
        || meta.sentiment_label
        || meta.primary_emotion
        || inferredFromValence
        || 'neutral'
    ) || inferredFromValence;

    const confidenceRaw =
        (nested && nested.confidence != null ? nested.confidence : null)
        ?? (meta.confidence != null ? meta.confidence : null)
        ?? (typeof valence === 'number' ? Math.min(1, Math.max(0.35, Math.abs(valence) + 0.25)) : 0.5);

    return {
        sentiment,
        dominant_emotion: String(primaryEmotion || sentiment || 'neutral').toLowerCase(),
        confidence: (() => {
            const parsedConfidence = Number(confidenceRaw);
            const safeConfidence = Number.isFinite(parsedConfidence) ? parsedConfidence : 0.5;
            return Math.max(0, Math.min(1, safeConfidence));
        })(),
        signals: (nested && Array.isArray(nested.signals)) ? nested.signals : (Array.isArray(meta.labels) ? meta.labels : []),
    };
}

function isLikelyNoise(item) {
    const text = String(item.content || '').trim();
    const meta = item.metadata || {};
    const snippet = String(meta.text_snippet || '').trim();
    const combined = `${text} ${snippet}`.toLowerCase();

    const hasSessionJson =
        ((text.startsWith('[') || text.startsWith('{'))
            && text.includes('"role"')
            && text.includes('"content"'))
        || combined.includes('"role":"user"')
        || combined.includes("'role': 'user'");

    const hasTestMarker = /\b(test|dummy|abc123|lorem ipsum|live test post|post 42)\b/i.test(combined);

    return hasSessionJson || hasTestMarker;
}

function sanitizeSentimentItems(items) {
    return items.filter(item => {
        if (isLikelyNoise(item)) return false;
        const sent = getSentData(item).sentiment;
        return ['positive', 'negative', 'uncertain', 'neutral'].includes(sent);
    });
}

function getSentiment(item) {
    return getSentData(item).sentiment;
}

function getEmotion(item) {
    return getSentData(item).dominant_emotion || getSentiment(item);
}

function renderCharts(items) {
    if (items.length === 0) {
        // Show placeholder charts with zero data
        const emptyData = { positive: 0, negative: 0, uncertain: 0, neutral: 0 };
        renderDistChart(emptyData);
        renderTimelineChart({});
        return;
    }

    const counts = { positive: 0, negative: 0, uncertain: 0, neutral: 0 };
    items.forEach(i => { const s = getSentiment(i); counts[s] = (counts[s] || 0) + 1; });
    renderDistChart(counts);

    const byDay = {};
    items.forEach(i => {
        const day = (i.created_at || '').slice(0, 10);
        if (!day) return;
        if (!byDay[day]) byDay[day] = { positive: 0, negative: 0, uncertain: 0, neutral: 0 };
        const s = getSentiment(i);
        if (byDay[day][s] !== undefined) byDay[day][s]++;
    });
    renderTimelineChart(byDay);
}

function renderDistChart(counts) {
    if (_charts['dist']) _charts['dist'].destroy();
    _charts['dist'] = new Chart(document.getElementById('chart-distribution'), {
        type: 'doughnut',
        data: {
            labels: ['Positive', 'Negative', 'Uncertain', 'Neutral'],
            datasets: [{
                data: [counts.positive, counts.negative, counts.uncertain, counts.neutral],
                backgroundColor: ['#22c55e', '#ef4444', '#f59e0b', '#6b7280'],
                borderWidth: 0
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: { legend: { position: 'bottom', labels: { color: '#94a3b8', font: { size: 12 } } } }
        }
    });
}

function renderTimelineChart(byDay) {
    const days = Object.keys(byDay).sort();
    const labels = days.length ? days : ['No data yet'];
    const series = (key) => days.length ? days.map(d => byDay[d][key] || 0) : [0];
    if (_charts['timeline']) _charts['timeline'].destroy();
    _charts['timeline'] = new Chart(document.getElementById('chart-timeline'), {
        type: 'bar',
        data: {
            labels,
            datasets: [
                { label: 'Positive', data: series('positive'), backgroundColor: '#22c55e', stack: 'a' },
                { label: 'Negative', data: series('negative'), backgroundColor: '#ef4444', stack: 'a' },
                { label: 'Uncertain', data: series('uncertain'), backgroundColor: '#f59e0b', stack: 'a' },
                { label: 'Neutral', data: series('neutral'), backgroundColor: '#6b7280', stack: 'a' },
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            scales: {
                x: { stacked: true, ticks: { color: '#94a3b8', font: { size: 11 } }, grid: { display: false } },
                y: { stacked: true, beginAtZero: true, ticks: { color: '#94a3b8', stepSize: 1 }, grid: { color: 'rgba(255,255,255,0.05)' } }
            },
            plugins: { legend: { position: 'bottom', labels: { color: '#94a3b8', font: { size: 12 } } } }
        }
    });
}

function renderList(items) {
    const filter = document.getElementById('filter-sentiment').value;
    const hideNeutral = document.getElementById('hide-neutral').checked;
    const speakerFilter = document.getElementById('filter-speaker').value;
    let filtered = items;
    if (filter) {
        filtered = filtered.filter(i => getSentiment(i) === filter);
    } else if (hideNeutral) {
        filtered = filtered.filter(i => getSentiment(i) !== 'neutral');
    }
    if (speakerFilter) {
        filtered = filtered.filter(i => (i.speaker || 'user') === speakerFilter);
    }
    const agentFilter = document.getElementById('filter-agent').value;
    if (agentFilter) {
        filtered = filtered.filter(i => (i.agent_id || '') === agentFilter);
    }

    document.getElementById('result-count').textContent = `${filtered.length} event${filtered.length !== 1 ? 's' : ''}`;

    if (filtered.length === 0) {
        // Show a helpful zero-state with seeded memory context
        let html = '<div class="empty-state">';
        html += '<h3 style="margin-bottom:10px">ğŸ’­ No sentiment analysis yet</h3>';
        if (_seedItems.length > 0) {
            html += `<p style="margin-bottom:15px">${_seedItems.length} memories are available in the knowledge base. Sentiment analysis will populate as Aria processes conversations.</p>`;
            html += '<p style="font-size:12px;color:var(--text-muted)">You can trigger analysis via: <code>POST /api/analysis/sentiment/message</code></p>';
        } else {
            html += '<p>Aria will detect sentiment as conversations happen. The memory bridge cron job seeds data every 3 hours.</p>';
        }
        html += '</div>';
        document.getElementById('sentiment-list').innerHTML = html;
        return;
    }

    document.getElementById('sentiment-list').innerHTML = filtered.map(item => {
        const sentiment = getSentiment(item);
        const emotion = getEmotion(item);
        const sentData = getSentData(item);
        const confidence = sentData.confidence != null ? `${Math.round(sentData.confidence * 100)}%` : '';
        const signals = (sentData.signals || []).slice(0, 3).join(', ');
        const time = item.created_at ? formatTime(item.created_at) : '';
        const content = item.content || '';
        const sentimentTitle = sentiment.charAt(0).toUpperCase() + sentiment.slice(1);
        const emotionSubtitle = emotion && emotion !== sentiment && emotion !== 'neutral' ? ` â€¢ ${emotion}` : '';

        // Speaker attribution
        const speaker = item.speaker || 'user';
        const agentId = item.agent_id || '';
        const channel = item.source_channel || '';
        let speakerLabel, speakerIcon, speakerClass;
        if (speaker === 'assistant') {
            speakerIcon = 'ğŸ¤–';
            speakerLabel = agentId ? `Aria Â· ${agentId}` : 'Aria';
            speakerClass = 'assistant';
        } else if (speaker === 'system') {
            speakerIcon = 'âš™ï¸';
            speakerLabel = 'System';
            speakerClass = 'system';
        } else {
            speakerIcon = 'ğŸ‘¤';
            speakerLabel = agentId && agentId !== 'main' ? `User Â· ${agentId}` : 'User';
            speakerClass = 'user';
        }

        return `
        <div class="sentiment-card">
            <div class="sentiment-indicator ${sentiment}"></div>
            <div class="sentiment-body">
                <div class="sentiment-header">
                    <span class="sentiment-emotion ${sentiment}">
                        ${({'frustration':'ğŸ˜¤','frustrated':'ğŸ˜¤','angry':'ğŸ˜¡','satisfaction':'ğŸ˜Š','satisfied':'ğŸ˜Š','happy':'ğŸ˜„','excited':'ğŸ‰','sad':'ğŸ˜¢','confusion':'ğŸ¤”','confused':'ğŸ¤”','neutral':'ğŸ˜¶','assertive':'ğŸ’ª','positive':'ğŸ˜Š','negative':'ğŸ˜Ÿ'})[emotion] || 'ğŸ˜'}
                        ${sentimentTitle}${emotionSubtitle}
                    </span>
                    <span style="display:flex;align-items:center;gap:8px">
                        <span class="speaker-badge ${speakerClass}">${speakerIcon} ${escapeHtml(speakerLabel)}</span>
                        <span class="sentiment-time">${time}</span>
                    </span>
                </div>
                <div class="sentiment-content">${escapeHtml(content)}</div>
                <div class="sentiment-meta">
                    ${confidence ? `<span>ğŸ¯ ${confidence} confidence</span>` : ''}
                    ${signals ? `<span>ğŸ“¡ ${escapeHtml(signals)}</span>` : ''}
                    <span>â­ ${(item.importance || 0).toFixed(1)}</span>
                </div>
            </div>
        </div>`;
    }).join('');
}

function formatTime(iso) {
    try {
        const d = new Date(iso);
        const now = new Date();
        const diff = now - d;
        if (diff < 60000) return 'just now';
        if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
        if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
    } catch { return iso; }
}

// Re-render with current filters (no re-fetch)
function renderFiltered() {
    renderList(_allItems);
}

// Initial load + auto-refresh every 30s
loadScore();
loadSentiment();
setInterval(() => { loadScore(); loadSentiment(); }, 30_000);
</script>
{% endblock %}
